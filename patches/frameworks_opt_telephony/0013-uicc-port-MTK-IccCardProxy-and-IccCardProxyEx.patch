From 4b076dd550e5e164475ee3c0f18b9e40e156c347 Mon Sep 17 00:00:00 2001
From: Wang Xuerui <idontknw.wang@gmail.com>
Date: Sat, 3 Oct 2015 12:12:09 +0800
Subject: [PATCH] uicc: port MTK IccCardProxy and IccCardProxyEx

Change-Id: Ice343aae4e19b0ef4ad18d01c68a61a78c218950
---
 .../internal/telephony/CommandsInterface.java      |  13 +
 .../com/android/internal/telephony/IccCard.java    |  23 +-
 .../internal/telephony/uicc/IccCardProxy.java      |  85 ++++-
 .../telephony/uicc/UiccCardApplication.java        | 163 +++++++++
 .../internal/telephony/uicc/IccCardProxyEx.java    | 390 +++++++++++++++++++++
 5 files changed, 649 insertions(+), 25 deletions(-)
 create mode 100755 src/java/com/mediatek/internal/telephony/uicc/IccCardProxyEx.java

diff --git a/src/java/com/android/internal/telephony/CommandsInterface.java b/src/java/com/android/internal/telephony/CommandsInterface.java
index 71e70ff..2514aa7 100644
--- a/src/java/com/android/internal/telephony/CommandsInterface.java
+++ b/src/java/com/android/internal/telephony/CommandsInterface.java
@@ -114,6 +114,19 @@ public interface CommandsInterface {
     static final int CDMA_SMS_FAIL_CAUSE_OTHER_TERMINAL_PROBLEM     = 39;
     static final int CDMA_SMS_FAIL_CAUSE_ENCODING_PROBLEM           = 96;
 
+    //MTK AT CMD +ESMLCK
+    static final int CAT_NETWOEK                = 0;
+    static final int CAT_NETOWRK_SUBSET         = 1;
+    static final int CAT_SERVICE_PROVIDER       = 2;
+    static final int CAT_CORPORATE              = 3;
+    static final int CAT_SIM                    = 4;
+
+    static final int OP_UNLOCK                  = 0;
+    static final int OP_LOCK                    = 1;
+    static final int OP_ADD                     = 2;
+    static final int OP_REMOVE                  = 3;
+    static final int OP_PERMANENT_UNLOCK        = 4;
+
     //***** Methods
     RadioState getRadioState();
 
diff --git a/src/java/com/android/internal/telephony/IccCard.java b/src/java/com/android/internal/telephony/IccCard.java
index 1e8cf81..6e1d35b 100644
--- a/src/java/com/android/internal/telephony/IccCard.java
+++ b/src/java/com/android/internal/telephony/IccCard.java
@@ -21,6 +21,7 @@ import android.os.Message;
 
 import com.android.internal.telephony.IccCardConstants.State;
 import com.android.internal.telephony.uicc.IccCardApplicationStatus;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.PersoSubState;
 import com.android.internal.telephony.uicc.IccFileHandler;
 import com.android.internal.telephony.uicc.IccRecords;
 
@@ -242,7 +243,7 @@ public interface IccCard {
      *
      * @internal
      */
-    // public PersoSubState getNetworkPersoType();
+    public PersoSubState getNetworkPersoType();
 
     /**
      * Use to query indicated category's ME lock status
@@ -257,7 +258,7 @@ public interface IccCard {
      *
      * @internal
      */
-    // public void queryIccNetworkLock(int category, Message onComplete);
+    public void queryIccNetworkLock(int category, Message onComplete);
 
     /**
      * Use to set indicated category's ME lock status
@@ -277,8 +278,8 @@ public interface IccCard {
      *
      * @internal
      */
-    // public void setIccNetworkLockEnabled(int category,
-    //         int lockop, String password, String data_imsi, String gid1, String gid2, Message onComplete);
+    public void setIccNetworkLockEnabled(int category,
+            int lockop, String password, String data_imsi, String gid1, String gid2, Message onComplete);
 
     /**
      * Use to repolling icc card status (Used by SIM ME lock related enhancement feature)
@@ -287,22 +288,22 @@ public interface IccCard {
      *                   if yes, will broadcast TelephonyIntents.ACTION_UNLOCK_SIM_LOCK to notify.
      *                   if no, will notify by original TelephonyIntents.ACTION_SIM_STATE_CHANGED.
      */
-    // public void repollIccStateForModemSmlChangeFeatrue(boolean needIntent);
+    public void repollIccStateForModemSmlChangeFeatrue(boolean needIntent);
 
     /**
      * NFC API, use to exchange SIM IO.
      *
      * @internal
      */
-    // public void exchangeSimIo(int fileID, int command,
-    //                                        int p1, int p2, int p3, String pathID, String data, String pin2, Message onComplete);
+    public void exchangeSimIo(int fileID, int command,
+            int p1, int p2, int p3, String pathID, String data, String pin2, Message onComplete);
 
     /**
      * NFC API, use to get ATR.
      *
      * @internal
      */
-    // public void iccGetAtr(Message onComplete);
+    public void iccGetAtr(Message onComplete);
 
     public String getIccCardType();
 
@@ -311,12 +312,12 @@ public interface IccCard {
      *
      * @internal
      */
-    // public void openLogicalChannelWithSw(String AID, Message onComplete);
+    public void openLogicalChannelWithSw(String AID, Message onComplete);
     /**
      * Notifies handler in case of FDN changed
      */
-    // public void registerForFdnChanged(Handler h, int what, Object obj);
-    // public void unregisterForFdnChanged(Handler h);
+    public void registerForFdnChanged(Handler h, int what, Object obj);
+    public void unregisterForFdnChanged(Handler h);
 
     // Added by M end
 }
diff --git a/src/java/com/android/internal/telephony/uicc/IccCardProxy.java b/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
index 183ba7e..ed7bab6 100755
--- a/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
+++ b/src/java/com/android/internal/telephony/uicc/IccCardProxy.java
@@ -54,6 +54,8 @@ import com.android.internal.telephony.uicc.IccCardStatus.PinState;
 import com.android.internal.telephony.uicc.UiccController;
 import com.android.internal.telephony.uicc.RuimRecords;
 
+import com.mediatek.internal.telephony.uicc.IccCardProxyEx;
+
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 
@@ -103,6 +105,21 @@ public class IccCardProxy extends Handler implements IccCard {
     private static final int EVENT_SUBSCRIPTION_DEACTIVATED = 502;
     private static final int EVENT_CARRIER_PRIVILIGES_LOADED = 503;
 
+    // MTK
+    private static final int EVENT_ICC_RECOVERY = 100;
+    private static final int EVENT_ICC_FDN_CHANGED = 101;
+    private static final int EVENT_NOT_AVAILABLE = 102;
+
+    private static final String ICCID_STRING_FOR_NO_SIM = "N/A";
+    private String[] PROPERTY_ICCID_SIM = {
+        "ril.iccid.sim1",
+        "ril.iccid.sim2",
+        "ril.iccid.sim3",
+        "ril.iccid.sim4",
+    };
+
+    private static final String COMMON_SLOT_PROPERTY = "";
+
     private Integer mPhoneId = null;
 
     private final Object mLock = new Object();
@@ -113,6 +130,10 @@ public class IccCardProxy extends Handler implements IccCard {
     private RegistrantList mPinLockedRegistrants = new RegistrantList();
     private RegistrantList mPersoLockedRegistrants = new RegistrantList();
 
+    // MTK
+    private RegistrantList mRecoveryRegistrants = new RegistrantList();
+    private RegistrantList mFdnChangedRegistrants = new RegistrantList();
+
     private int mCurrentAppType = UiccController.APP_FAM_3GPP; //default to 3gpp?
     private UiccController mUiccController = null;
     private UiccCard mUiccCard = null;
@@ -127,6 +148,9 @@ public class IccCardProxy extends Handler implements IccCard {
     private boolean mIsCardStatusAvailable = false;
     private PersoSubState mPersoSubState = PersoSubState.PERSOSUBSTATE_UNKNOWN;
 
+    // MTK
+    private IccCardProxyEx mIccCardProxyEx;
+
     // Sim State events may be broadcasted before the siminfo table update has been
     // completed. Due to this such events may be broadcasted with dummy subId for a
     // particular slotId. Therefore, setExternalState once the siminfo table has been updated.
@@ -145,6 +169,7 @@ public class IccCardProxy extends Handler implements IccCard {
         mContext = context;
         mCi = ci;
         mPhoneId = phoneId;
+        mIccCardProxyEx = new IccCardProxyEx(context, ci);
         mCdmaSSM = CdmaSubscriptionSourceManager.getInstance(context,
                 ci, this, EVENT_CDMA_SUBSCRIPTION_SOURCE_CHANGED, null);
         mUiccController = UiccController.getInstance();
@@ -168,6 +193,7 @@ public class IccCardProxy extends Handler implements IccCard {
             mCi.unregisterForOn(this);
             mCi.unregisterForOffOrNotAvailable(this);
             mCdmaSSM.dispose(this);
+            mIccCardProxyEx.dispose();
         }
     }
 
@@ -288,6 +314,10 @@ public class IccCardProxy extends Handler implements IccCard {
                     setExternalState(State.NOT_READY);
                 }
                 break;
+            case EVENT_NOT_AVAILABLE:
+                log("handleMessage (EVENT_NOT_AVAILABLE)");
+                setExternalState(State.NOT_READY);
+                break;
             case EVENT_RADIO_ON:
                 mRadioOn = true;
                 if (!mInitialized) {
@@ -302,9 +332,29 @@ public class IccCardProxy extends Handler implements IccCard {
             case EVENT_ICC_CHANGED:
                 mIsCardStatusAvailable = true;
                 if (mInitialized) {
+                    AsyncResult ar = (AsyncResult) msg.obj;
+                    int index = mPhoneId;
+
+                    if (ar != null && ar.result instanceof Integer) {
+                        index = ((Integer) ar.result).intValue();
+                        log("handleMessage (EVENT_ICC_CHANGED), index=" + index + " mPhoneId=" + mPhoneId);
+                    } else {
+                        log("handleMessage (EVENT_ICC_CHANGED), come from myself, mPhoneId=" + mPhoneId);
+                    }
+
                     updateIccAvailability();
                 }
                 break;
+            case EVENT_ICC_RECOVERY: {
+                AsyncResult ar = (AsyncResult) msg.obj;
+                Integer index = (Integer) ar.result;
+                log("handleMessage (EVENT_ICC_RECOVERY) , index = " + index);
+                // if (index == mSlotId) {
+                if (DBG) log("mRecoveryRegistrants notify");
+                mRecoveryRegistrants.notifyRegistrants();
+                // }
+                break;
+            }
             case EVENT_ICC_ABSENT:
                 mAbsentRegistrants.notifyRegistrants();
                 setExternalState(State.ABSENT);
@@ -386,6 +436,10 @@ public class IccCardProxy extends Handler implements IccCard {
                 }
                 break;
 
+            case EVENT_ICC_FDN_CHANGED:
+                mFdnChangedRegistrants.notifyRegistrants();
+                break;
+
             case EVENT_CARRIER_PRIVILIGES_LOADED:
                 log("EVENT_CARRIER_PRIVILEGES_LOADED");
                 if (mUiccCard != null) {
@@ -490,12 +544,19 @@ public class IccCardProxy extends Handler implements IccCard {
                 setExternalState(State.PUK_REQUIRED);
                 break;
             case APPSTATE_SUBSCRIPTION_PERSO:
+                /*  [mtk02772][ALPS00437082]
+                    mediatek platform will set network locked for all of subState (5 type of network locked)
+                */
+                setExternalState(State.PERSO_LOCKED);
+
+                /*
                 if (mUiccApplication.isPersoLocked()) {
                     mPersoSubState = mUiccApplication.getPersoSubState();
                     setExternalState(State.PERSO_LOCKED);
                 } else {
                     setExternalState(State.UNKNOWN);
                 }
+                */
                 break;
             case APPSTATE_READY:
                 setExternalState(State.READY);
@@ -655,7 +716,15 @@ public class IccCardProxy extends Handler implements IccCard {
         switch (state) {
             case PIN_REQUIRED: return IccCardConstants.INTENT_VALUE_LOCKED_ON_PIN;
             case PUK_REQUIRED: return IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK;
-            case PERSO_LOCKED: return IccCardConstants.INTENT_VALUE_LOCKED_PERSO;
+            case PERSO_LOCKED:  // return IccCardConstants.INTENT_VALUE_LOCKED_PERSO;
+                switch (mUiccApplication.getPersoSubState()) {
+                    case PERSOSUBSTATE_SIM_NETWORK: return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK;
+                    case PERSOSUBSTATE_SIM_NETWORK_SUBSET: return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK_SUBSET;
+                    case PERSOSUBSTATE_SIM_CORPORATE: return IccCardConstants.INTENT_VALUE_LOCKED_CORPORATE;
+                    case PERSOSUBSTATE_SIM_SERVICE_PROVIDER: return IccCardConstants.INTENT_VALUE_LOCKED_SERVICE_PROVIDER;
+                    case PERSOSUBSTATE_SIM_SIM: return IccCardConstants.INTENT_VALUE_LOCKED_SIM;
+                    default: return null;
+                }
             case PERM_DISABLED: return IccCardConstants.INTENT_VALUE_ABSENT_ON_PERM_DISABLED;
             case CARD_IO_ERROR: return IccCardConstants.INTENT_VALUE_ICC_CARD_IO_ERROR;
             default: return null;
@@ -999,20 +1068,17 @@ public class IccCardProxy extends Handler implements IccCard {
      *
      * @return SIM ME Lock type
      */
-    /*
     public PersoSubState getNetworkPersoType() {
         if (mUiccApplication != null) {
             return mUiccApplication.getPersoSubState();
         }
         return PersoSubState.PERSOSUBSTATE_UNKNOWN;
     }
-    */
 
     /**
      * Check whether ICC network lock is enabled
      * This is an async call which returns lock state to applications directly
      */
-    /*
     @Override
     public void queryIccNetworkLock(int category, Message onComplete) {
         if (DBG) log("queryIccNetworkLock(): category =  " + category);
@@ -1027,13 +1093,11 @@ public class IccCardProxy extends Handler implements IccCard {
             }
         }
     }
-    */
 
     /**
      * Set the ICC network lock enabled or disabled
      * When the operation is complete, onComplete will be sent to its handler
      */
-    /*
     @Override
     public void setIccNetworkLockEnabled(int category,
             int lockop, String password, String data_imsi, String gid1, String gid2, Message onComplete) {
@@ -1051,16 +1115,14 @@ public class IccCardProxy extends Handler implements IccCard {
             }
         }
     }
-    */
 
     /**
      * Used by SIM ME lock related enhancement feature(Modem SML change feature).
      */
-    /*
     public void repollIccStateForModemSmlChangeFeatrue(boolean needIntent) {
         if (DBG) log("repollIccStateForModemSmlChangeFeatrue, needIntent = " + needIntent);
         synchronized (mLock) {
-            mUiccController.repollIccStateForModemSmlChangeFeatrue(mSlotId, needIntent);
+            mUiccController.repollIccStateForModemSmlChangeFeatrue(mPhoneId, needIntent);
         }
     }
 
@@ -1082,7 +1144,6 @@ public class IccCardProxy extends Handler implements IccCard {
             mUiccCard.iccOpenChannelWithSw(AID, onComplete);
         }
     }
-    */
 
     // retrun usim property or use uicccardapplication app type
     public String getIccCardType() {
@@ -1092,7 +1153,6 @@ public class IccCardProxy extends Handler implements IccCard {
         return "";
     }
 
-    /*
     public void registerForRecovery(Handler h, int what, Object obj) {
         synchronized (mLock) {
             Registrant r = new Registrant(h, what, obj);
@@ -1110,12 +1170,10 @@ public class IccCardProxy extends Handler implements IccCard {
             mRecoveryRegistrants.remove(h);
         }
     }
-    */
 
     /**
      * Notifies handler in case of FDN changed
      */
-    /*
     @Override
     public void registerForFdnChanged(Handler h, int what, Object obj) {
         synchronized (mLock) {
@@ -1137,7 +1195,6 @@ public class IccCardProxy extends Handler implements IccCard {
             mFdnChangedRegistrants.remove(h);
         }
     }
-    */
 
     // Added by M end
 }
diff --git a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
index cce75f1..c455256 100644
--- a/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
+++ b/src/java/com/android/internal/telephony/uicc/UiccCardApplication.java
@@ -22,6 +22,7 @@ import android.os.Handler;
 import android.os.Message;
 import android.os.Registrant;
 import android.os.RegistrantList;
+import android.os.SystemProperties;
 import android.telephony.Rlog;
 
 import com.android.internal.telephony.CommandsInterface;
@@ -88,6 +89,37 @@ public class UiccCardApplication {
     private RegistrantList mPinLockedRegistrants = new RegistrantList();
     private RegistrantList mPersoLockedRegistrants = new RegistrantList();
 
+    // MTK
+    private int mSlotId;
+
+    private static final int EVENT_QUERY_NETWORK_LOCK_DONE = 101;
+    private static final int EVENT_CHANGE_NETWORK_LOCK_DONE = 102;
+    private static final int EVENT_RADIO_NOTAVAILABLE = 103;
+
+    // [02772] start
+    static final String[] UICCCARDAPPLICATION_PROPERTY_RIL_UICC_TYPE = {
+        "gsm.ril.uicctype",
+        "gsm.ril.uicctype.2",
+        "gsm.ril.uicctype.3",
+        "gsm.ril.uicctype.4",
+    };
+    protected String mIccType = null; /* Add for USIM detect */
+    // [02772] end
+
+    private static final String PROPERTY_PIN1_RETRY[] = {
+        "gsm.sim.retry.pin1",
+        "gsm.sim.retry.pin1.2",
+        "gsm.sim.retry.pin1.3",
+        "gsm.sim.retry.pin1.4",
+    };
+
+    private static final String PROPERTY_PIN2_RETRY[] = {
+        "gsm.sim.retry.pin2",
+        "gsm.sim.retry.pin2.2",
+        "gsm.sim.retry.pin2.3",
+        "gsm.sim.retry.pin2.4",
+    };
+
     UiccCardApplication(UiccCard uiccCard,
                         IccCardApplicationStatus as,
                         Context c,
@@ -107,6 +139,8 @@ public class UiccCardApplication {
         mContext = c;
         mCi = ci;
 
+        mSlotId = mUiccCard.getSlotId();
+
         mIccFh = createIccFileHandler(as.app_type);
         mIccRecords = createIccRecords(as.app_type, mContext, mCi);
         if (mAppState == AppState.APPSTATE_READY) {
@@ -146,6 +180,8 @@ public class UiccCardApplication {
                 mIccRecords = createIccRecords(as.app_type, c, ci);
             }
 
+            // MTK log
+            if (DBG) log("mPersoSubState: " + mPersoSubState + " oldPersoSubState: " + oldPersoSubState);
             if (mPersoSubState != oldPersoSubState &&
                     isPersoLocked()) {
                 notifyPersoLockedRegistrantsIfNeeded(null);
@@ -409,6 +445,28 @@ public class UiccCardApplication {
                     ar = (AsyncResult)msg.obj;
                     onChangeFacilityLock(ar);
                     break;
+                case EVENT_QUERY_NETWORK_LOCK_DONE:
+                    if (DBG) log("handleMessage (EVENT_QUERY_NETWORK_LOCK)");
+                    ar = (AsyncResult) msg.obj;
+
+                    if (ar.exception != null) {
+                        Rlog.e(LOG_TAG, "Error query network lock with exception "
+                            + ar.exception);
+                    }
+                    AsyncResult.forMessage((Message) ar.userObj, ar.result, ar.exception);
+                    ((Message) ar.userObj).sendToTarget();
+                    break;
+                case EVENT_CHANGE_NETWORK_LOCK_DONE:
+                    if (DBG) log("handleMessage (EVENT_CHANGE_NETWORK_LOCK)");
+                    ar = (AsyncResult) msg.obj;
+                    if (ar.exception != null) {
+                        Rlog.e(LOG_TAG, "Error change network lock with exception "
+                            + ar.exception);
+                    }
+                    AsyncResult.forMessage(((Message) ar.userObj)).exception
+                                                        = ar.exception;
+                    ((Message) ar.userObj).sendToTarget();
+                    break;
                 case EVENT_RADIO_UNAVAILABLE:
                     if (DBG) log("handleMessage (EVENT_RADIO_UNAVAILABLE)");
                     mAppState = AppState.APPSTATE_UNKNOWN;
@@ -779,12 +837,34 @@ public class UiccCardApplication {
         }
     }
 
+    // MTK implementation of getIccFdnAvailable
+    public boolean getIccFdnAvailableMTK() {
+        if (mIccRecords == null) {
+            if (DBG) log("isFdnExist mIccRecords == null");
+            return false;
+        }
+
+        UsimServiceTable ust = mIccRecords.getUsimServiceTable();
+        if (ust != null && ust.isAvailable(UsimServiceTable.UsimService.FDN)) {
+            if (DBG) log("isFdnExist return true");
+            return true;
+        } else {
+            if (DBG) log("isFdnExist return false");
+            return false;
+        }
+    }
+
     /**
      * Check whether fdn (fixed dialing number) service is available.
      * @return true if ICC fdn service available
      *         false if ICC fdn service not available
      */
     public boolean getIccFdnAvailable() {
+        final boolean mtkResult = getIccFdnAvailableMTK();
+        if (mtkResult != mIccFdnAvailable) {
+            if (DBG) log("getIccFdnAvailable: WARNING: mIccFdnAvailable="
+                    + mIccFdnAvailable + " disagrees with mtkResult!");
+        }
         return mIccFdnAvailable;
     }
 
@@ -958,4 +1038,87 @@ public class UiccCardApplication {
         }
         pw.flush();
     }
+
+    // MTK
+    private RegistrantList mFdnChangedRegistrants = new RegistrantList();
+
+    public void registerForFdnChanged(Handler h, int what, Object obj) {
+        synchronized (mLock) {
+            Registrant r = new Registrant(h, what, obj);
+            mFdnChangedRegistrants.add(r);
+        }
+    }
+
+    public void unregisterForFdnChanged(Handler h) {
+        synchronized (mLock) {
+            mFdnChangedRegistrants.remove(h);
+        }
+    }
+
+    public int getSlotId() {
+        return mSlotId;
+    }
+
+    private void notifyFdnChangedRegistrants() {
+        if (mDestroyed) {
+            return;
+        }
+
+        mFdnChangedRegistrants.notifyRegistrants();
+    }
+
+    public String getIccCardType() {
+         if (mIccType == null || mIccType.equals("")) {
+            mIccType = SystemProperties.get(UICCCARDAPPLICATION_PROPERTY_RIL_UICC_TYPE[mSlotId]);
+         }
+
+        log("getIccCardType(): mIccType = " + mIccType);
+        return mIccType;
+    }
+
+    //MTK-START [mtk80601][111215][ALPS00093395]
+    /**
+     * Check whether ICC network lock is enabled
+     * This is an async call which returns lock state to applications directly
+     */
+    public void queryIccNetworkLock(int category, Message onComplete) {
+        if (DBG) log("queryIccNetworkLock(): category =  " + category);
+
+        switch(category) {
+            case CommandsInterface.CAT_NETWOEK:
+            case CommandsInterface.CAT_NETOWRK_SUBSET:
+            case CommandsInterface.CAT_CORPORATE:
+            case CommandsInterface.CAT_SERVICE_PROVIDER:
+            case CommandsInterface.CAT_SIM:
+                mCi.queryNetworkLock(category, mHandler.obtainMessage(EVENT_QUERY_NETWORK_LOCK_DONE, onComplete));
+                break;
+            default:
+                Rlog.e(LOG_TAG, "queryIccNetworkLock unknown category = " + category);
+                break;
+        }
+   }
+
+    /**
+     * Set the ICC network lock enabled or disabled
+     * When the operation is complete, onComplete will be sent to its handler
+     */
+    public void setIccNetworkLockEnabled(int category,
+            int lockop, String password, String data_imsi, String gid1, String gid2, Message onComplete) {
+        if (DBG) log("SetIccNetworkEnabled(): category = " + category
+            + " lockop = " + lockop + " password = " + password
+            + " data_imsi = " + data_imsi + " gid1 = " + gid1 + " gid2 = " + gid2);
+
+        switch(lockop) {
+            case CommandsInterface.OP_REMOVE:
+            case CommandsInterface.OP_ADD:
+            case CommandsInterface.OP_LOCK:
+            case CommandsInterface.OP_PERMANENT_UNLOCK:
+            case CommandsInterface.OP_UNLOCK:
+                mCi.setNetworkLock(category, lockop, password, data_imsi, gid1, gid2, mHandler.obtainMessage(EVENT_CHANGE_NETWORK_LOCK_DONE, onComplete));
+                break;
+            default:
+                Rlog.e(LOG_TAG, "SetIccNetworkEnabled unknown operation" + lockop);
+                break;
+        }
+    }
 }
diff --git a/src/java/com/mediatek/internal/telephony/uicc/IccCardProxyEx.java b/src/java/com/mediatek/internal/telephony/uicc/IccCardProxyEx.java
new file mode 100755
index 0000000..4ba67ac
--- /dev/null
+++ b/src/java/com/mediatek/internal/telephony/uicc/IccCardProxyEx.java
@@ -0,0 +1,390 @@
+/*
+ * Copyright (C) 2012 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.mediatek.internal.telephony.uicc;
+
+
+import static android.Manifest.permission.READ_PHONE_STATE;
+import android.app.ActivityManagerNative;
+import android.content.Context;
+import android.content.Intent;
+import android.os.AsyncResult;
+import android.os.Handler;
+import android.os.Message;
+import android.os.UserHandle;
+
+import android.telephony.TelephonyManager;
+import android.telephony.SubscriptionManager;
+import android.telephony.Rlog;
+
+import com.android.internal.telephony.CommandsInterface;
+import com.android.internal.telephony.IccCardConstants;
+import com.android.internal.telephony.IccCardConstants.State;
+import com.android.internal.telephony.TelephonyIntents;
+import com.android.internal.telephony.uicc.UiccController;
+import com.android.internal.telephony.uicc.UiccCard;
+import com.android.internal.telephony.uicc.UiccCardApplication;
+import com.android.internal.telephony.uicc.IccRecords;
+import com.android.internal.telephony.uicc.IccFileHandler;
+import com.android.internal.telephony.uicc.IccCardStatus;
+import com.android.internal.telephony.uicc.IccCardStatus.CardState;
+import com.android.internal.telephony.uicc.IccCardApplicationStatus.PersoSubState;
+import com.android.internal.telephony.PhoneConstants;
+
+/**
+ * @Deprecated use {@link UiccController}.getUiccCard instead.
+ *
+ * The Phone App assumes that there is only one icc card, and one icc application
+ * available at a time. Moreover, it assumes such object (represented with IccCard)
+ * is available all the time (whether {@link RILConstants.RIL_REQUEST_GET_SIM_STATUS} returned
+ * or not, whether card has desired application or not, whether there really is a card in the
+ * slot or not).
+ *
+ * UiccController, however, can handle multiple instances of icc objects (multiple
+ * {@link UiccCardApplication}, multiple {@link IccFileHandler}, multiple {@link IccRecords})
+ * created and destroyed dynamically during phone operation.
+ *
+ * This class implements the IccCard interface that is always available (right after default
+ * phone object is constructed) to expose the current (based on voice radio technology)
+ * application on the uicc card, so that external apps won't break.
+ */
+
+public class IccCardProxyEx extends Handler {
+    private static final boolean DBG = true;
+    private static final String LOG_TAG = "IccCardProxyEx";
+
+    private static final int EVENT_RADIO_OFF_OR_UNAVAILABLE = 1;
+    private static final int EVENT_ICC_CHANGED = 2;
+    private static final int EVENT_APP_READY = 3;
+    private static final int EVENT_RECORDS_LOADED = 4;
+
+    private final Object mLock = new Object();
+    private Context mContext;
+    private CommandsInterface mCi;
+
+    private static final int APPLICATION_ID_ISIM = 0;
+    private static final int APPLICATION_ID_MAX = 1;
+
+    private int mCurrentAppType = UiccController.APP_FAM_IMS;
+    private UiccController mUiccController = null;
+
+    private UiccCard mUiccCard = null;
+    private UiccCardApplication[] mUiccApplication =
+        new UiccCardApplication[IccCardStatus.CARD_MAX_APPS];
+    private IccRecords[] mIccRecords =
+        new IccRecords[IccCardStatus.CARD_MAX_APPS];
+
+    private State[] mExternalState = new State[]{State.UNKNOWN};
+    private int mSlotId;
+
+    public IccCardProxyEx(Context context, CommandsInterface ci) {
+        this(context, ci, PhoneConstants.SIM_ID_1);
+    }
+
+    public IccCardProxyEx(Context context, CommandsInterface ci, int slotId) {
+        this.mContext = context;
+        this.mCi = ci;
+        // FIXME: slotId or phoneId?
+        mSlotId = slotId;
+
+        Integer index = new Integer(mSlotId);
+        mUiccController = UiccController.getInstance();
+        ci.registerForOffOrNotAvailable(this, EVENT_RADIO_OFF_OR_UNAVAILABLE, index);
+        mUiccController.registerForApplicationChanged(this, EVENT_ICC_CHANGED, index);
+
+        setExternalState(State.NOT_READY, 0);
+        log("Creating");
+    }
+
+    public void dispose() {
+        synchronized (mLock) {
+            log("Disposing");
+            //Cleanup icc references
+            mCi.unregisterForOffOrNotAvailable(this);
+            mUiccController.unregisterForApplicationChanged(this);
+            mUiccController = null;
+        }
+    }
+
+    public void handleMessage(Message msg) {
+        AsyncResult ar;
+        int appId;
+        log("receive message " + msg.what);
+
+        Integer index = getIndex(msg);
+
+        if (index < 0 || index >= TelephonyManager.getDefault().getPhoneCount() || index != mSlotId) {
+            loge("Invalid index : " + index + " received with event " + msg.what);
+            return;
+        }
+
+        switch (msg.what) {
+            case EVENT_RADIO_OFF_OR_UNAVAILABLE:
+                for (int i = 0; i < APPLICATION_ID_MAX; i++) {
+                    setExternalState(State.NOT_READY, i);
+                }
+                break;
+
+            case EVENT_ICC_CHANGED:
+                updateIccAvailability(0);
+                break;
+
+            case EVENT_APP_READY:
+                ar = (AsyncResult) (msg.obj);
+                appId = ((Integer) ar.userObj).intValue();
+                setExternalState(State.READY, appId);
+                break;
+
+            case EVENT_RECORDS_LOADED:
+                ar = (AsyncResult) (msg.obj);
+                appId = ((Integer) ar.userObj).intValue();
+                broadcastIccStateChangedIntent(IccCardConstants.INTENT_VALUE_ICC_LOADED, null, appId);
+
+                break;
+            default:
+                loge("Unhandled message with number: " + msg.what);
+                break;
+        }
+    }
+
+    private void updateIccAvailability(int appId) {
+        synchronized (mLock) {
+            UiccCard newCard = mUiccController.getUiccCard();
+            CardState state = CardState.CARDSTATE_ABSENT;
+            UiccCardApplication newApp = null;
+            IccRecords newRecords = null;
+            int appType = 0;
+
+            switch(appId) {
+                case 0:
+                    appType = UiccController.APP_FAM_IMS;
+                    break;
+                default:
+                    break;
+            }
+
+            if (newCard != null) {
+                state = newCard.getCardState();
+                newApp = newCard.getApplication(appType);
+                if (newApp != null) {
+                    newRecords = newApp.getIccRecords();
+                }
+            }
+
+            if (mIccRecords[appId] != newRecords || mUiccApplication[appId] != newApp || mUiccCard != newCard) {
+                if (DBG) log("Icc changed. Reregestering.");
+                unregisterUiccCardEvents(appId);
+                mUiccCard = newCard;
+                mUiccApplication[appId] = newApp;
+                mIccRecords[appId] = newRecords;
+                registerUiccCardEvents(appId);
+            }
+
+            updateExternalState(appId);
+        }
+    }
+
+    private void updateExternalState(int appId) {
+
+        if (mUiccCard == null) {
+            setExternalState(State.NOT_READY, appId);
+            return;
+        } else if (mUiccCard.getCardState() == CardState.CARDSTATE_ABSENT) {
+            setExternalState(State.ABSENT, appId);
+            return;
+        }
+
+        if (DBG) log("CardState = " + mUiccCard.getCardState());
+
+        if (mUiccCard.getCardState() == CardState.CARDSTATE_ERROR ||
+                mUiccApplication[appId] == null) {
+            setExternalState(State.UNKNOWN, appId);
+            return;
+        }
+
+        if (DBG) log("application state = " + mUiccApplication[appId].getState());
+        if (DBG) log("mUiccApplication[appId] = " + mUiccApplication[appId]);
+
+        switch (mUiccApplication[appId].getState()) {
+            case APPSTATE_UNKNOWN:
+            case APPSTATE_DETECTED:
+                setExternalState(State.UNKNOWN, appId);
+                break;
+            case APPSTATE_READY:
+                setExternalState(State.READY, appId);
+                break;
+        }
+    }
+
+    private void registerUiccCardEvents(int appId) {
+        Integer aid = new Integer(appId);
+        if (mUiccApplication[appId] != null) {
+            mUiccApplication[appId].registerForReady(this, EVENT_APP_READY, (Object) aid);
+        }
+        if (mIccRecords[appId] != null) {
+            mIccRecords[appId].registerForRecordsLoaded(this, EVENT_RECORDS_LOADED, (Object) aid);
+        }
+    }
+
+    private void unregisterUiccCardEvents(int appId) {
+        if (mUiccApplication[appId] != null) mUiccApplication[appId].unregisterForReady(this);
+        if (mIccRecords[appId] != null) mIccRecords[appId].unregisterForRecordsLoaded(this);
+    }
+
+    private void broadcastIccStateChangedIntent(String value, String reason, int appId) {
+        synchronized (mLock) {
+
+            Intent intent = new Intent(TelephonyIntents.ACTION_SIM_STATE_CHANGED_MULTI_APPLICATION);
+            intent.putExtra(PhoneConstants.PHONE_NAME_KEY, "Phone");
+            intent.putExtra(IccCardConstants.INTENT_KEY_ICC_STATE, value);
+            intent.putExtra(IccCardConstants.INTENT_KEY_LOCKED_REASON, reason);
+            // FIXME: putPhoneIdAndSubIdExtra is phone based API, slot id might not equal to phone id.
+            SubscriptionManager.putPhoneIdAndSubIdExtra(intent, mSlotId);
+            intent.putExtra("appId", appId);
+            if (DBG) log("Broadcasting intent ACTION_SIM_STATE_CHANGED_MULTI_APPLICATION " +  value
+                    + " reason " + reason + " slotd id " + mSlotId + " app id " + appId);
+            ActivityManagerNative.broadcastStickyIntent(intent, READ_PHONE_STATE,
+                    UserHandle.USER_ALL);
+        }
+    }
+
+    private void setExternalState(State newState, boolean override, int appId) {
+        synchronized (mLock) {
+            if (DBG) log("setExternalState(): mExternalState = " + mExternalState[appId] +
+                " newState =  " + newState + " override = " + override);
+
+            if (!override && newState == mExternalState[appId]) {
+                return;
+            }
+
+            mExternalState[appId] = newState;
+
+            broadcastIccStateChangedIntent(getIccStateIntentString(mExternalState[appId]),
+                    getIccStateReason(mExternalState[appId], appId), appId);
+        }
+    }
+
+    private void setExternalState(State newState, int appId) {
+        if (DBG) log("setExternalState(): newState =  " + newState + "appId = " + appId);
+        setExternalState(newState, false, appId);
+    }
+
+    private String getIccStateIntentString(State state) {
+        switch (state) {
+            case ABSENT: return IccCardConstants.INTENT_VALUE_ICC_ABSENT;
+            case PIN_REQUIRED: return IccCardConstants.INTENT_VALUE_ICC_LOCKED;
+            case PUK_REQUIRED: return IccCardConstants.INTENT_VALUE_ICC_LOCKED;
+            case PERSO_LOCKED: return IccCardConstants.INTENT_VALUE_ICC_LOCKED;
+            case READY: return IccCardConstants.INTENT_VALUE_ICC_READY;
+            case NOT_READY: return IccCardConstants.INTENT_VALUE_ICC_NOT_READY;
+            case PERM_DISABLED: return IccCardConstants.INTENT_VALUE_ICC_LOCKED;
+            default: return IccCardConstants.INTENT_VALUE_ICC_UNKNOWN;
+        }
+    }
+
+    /**
+     * Locked state have a reason (PIN, PUK, NETWORK, PERM_DISABLED)
+     * @return reason
+     */
+    private String getIccStateReason(State state, int appId) {
+        switch (state) {
+            case PIN_REQUIRED: return IccCardConstants.INTENT_VALUE_LOCKED_ON_PIN;
+            case PUK_REQUIRED: return IccCardConstants.INTENT_VALUE_LOCKED_ON_PUK;
+            case PERSO_LOCKED:
+                switch (mUiccApplication[appId].getPersoSubState()) {
+                    case PERSOSUBSTATE_SIM_NETWORK: return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK;
+                    case PERSOSUBSTATE_SIM_NETWORK_SUBSET: return IccCardConstants.INTENT_VALUE_LOCKED_NETWORK_SUBSET;
+                    case PERSOSUBSTATE_SIM_CORPORATE: return IccCardConstants.INTENT_VALUE_LOCKED_CORPORATE;
+                    case PERSOSUBSTATE_SIM_SERVICE_PROVIDER: return IccCardConstants.INTENT_VALUE_LOCKED_SERVICE_PROVIDER;
+                    case PERSOSUBSTATE_SIM_SIM: return IccCardConstants.INTENT_VALUE_LOCKED_SIM;
+                    default: return null;
+                }
+            case PERM_DISABLED: return IccCardConstants.INTENT_VALUE_ABSENT_ON_PERM_DISABLED;
+            default: return null;
+       }
+    }
+
+    /* IccCard interface implementation */
+    // TODO: MTK use ICS solution, there is only three state, radio.on, radio.off, radio.not.available
+
+    public State getState(int appId) {
+        synchronized (mLock) {
+            return mExternalState[appId];
+        }
+    }
+
+
+    public IccRecords getIccRecords(int family) {
+        int appId = -1;
+        synchronized (mLock) {
+            switch (family) {
+                case UiccController.APP_FAM_IMS:
+                    appId = 0;
+                    break;
+                default:
+                    if (DBG) log("Not Support");
+                    break;
+            }
+
+            if (appId != -1) {
+                return mIccRecords[appId];
+            } else {
+                return null;
+            }
+        }
+    }
+
+    public IccFileHandler getIccFileHandler(int appId) {
+        synchronized (mLock) {
+            if (mUiccApplication[appId] != null) {
+                return mUiccApplication[appId].getIccFileHandler();
+            }
+            return null;
+        }
+    }
+
+    private Integer getIndex(Message msg) {
+        AsyncResult ar;
+        // FIXME: PhoneConstants.DEFAULT_CARD_INDEX will be changed?
+        Integer index = new Integer(PhoneConstants.DEFAULT_CARD_INDEX);
+
+        /*
+         * The events can be come in two ways. By explicitly sending it using
+         * sendMessage, in this case the user object passed is msg.obj and from
+         * the CommandsInterface, in this case the user object is msg.obj.userObj
+         */
+        if (msg != null) {
+            if (msg.obj != null && msg.obj instanceof Integer) {
+                index = (Integer) msg.obj;
+            } else if (msg.obj != null && msg.obj instanceof AsyncResult) {
+                ar = (AsyncResult) msg.obj;
+                if (ar.userObj != null && ar.userObj instanceof Integer) {
+                    index = (Integer) ar.userObj;
+                }
+            }
+        }
+        return index;
+    }
+
+
+    private void log(String msg) {
+        Rlog.d(LOG_TAG, "[SIM" + (mSlotId == 0 ? "1" : "2") + "] " + msg);
+    }
+
+    private void loge(String msg) {
+        Rlog.e(LOG_TAG, "[SIM" + (mSlotId == 0 ? "1" : "2") + "] " + msg);
+    }
+}
-- 
2.5.0

